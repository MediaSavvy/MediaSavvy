import { m as ShikiContext, c as CodeToThemedTokensOptions, T as ThemedToken } from './types/langs.mjs';
export { A as AnsiLanguage, f as Awaitable, B as BuiltinLanguage, a as BuiltinTheme, o as BundledHighlighterOptions, u as CodeOptionsMeta, s as CodeOptionsMultipleThemes, r as CodeOptionsSingleTheme, t as CodeOptionsThemes, C as CodeToHastOptions, q as CodeToHastOptionsCommon, d as CodeToTokensWithThemesOptions, F as FontStyle, n as HighlighterCoreOptions, H as HighlighterGeneric, E as HtmlRendererOptions, D as HtmlRendererOptionsCommon, e as IGrammar, I as IRawGrammar, L as LanguageInput, p as LanguageRegistration, h as MaybeArray, M as MaybeGetter, g as MaybeModule, P as PlainTextLanguage, b as RequireKeys, k as ResolveBundleKey, z as ShikijiTransformer, y as ShikijiTransformerContext, S as SpecialLanguage, j as StringLiteralUnion, i as ThemeInput, x as ThemeRegistration, w as ThemeRegistrationRaw, J as ThemedTokenExplanation, G as ThemedTokenScopeExplanation, v as TransformerOptions, l as loadWasm } from './types/langs.mjs';
export { G as GetHighlighterFactory, H as HighlighterCore, h as addClassToHast, d as createSingletonShorthands, c as createdBundledHighlighter, b as getHighlighterCore, g as getShikiContext, i as isPlaintext, f as isSpecialLang, e as toArray, a as toShikiTheme, t as tokenizeAnsiWithTheme } from './types/normalize.mjs';

declare function codeToThemedTokens(context: ShikiContext, code: string, options?: CodeToThemedTokensOptions): ThemedToken[][];

export { CodeToThemedTokensOptions, ShikiContext, ThemedToken, codeToThemedTokens };
